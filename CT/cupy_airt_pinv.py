import numpy as np
import cupy as cp
import cupy.linalg as cula
import cupyx.scipy.sparse as cusp
import scipy.io as sio
import time
import argparse

# Add Poisson noise
def add_noise(g,I):
    y = I*cp.exp(-g)
    y_n = cp.random.poisson(y)
    g_n = -cp.log(y_n/I)
    return g_n

# Compute operator norm for Landweber step size
def operator_norm(A,n_iter):
    N = A.shape[1]
    x = cp.random.randn(N,1)
    for i in range(n_iter):
        x = A.T*(A*x)
        x = x/cula.norm(x)
    L = cula.norm(A.T*(A*x))/cula.norm(x)
    return L

# Compute the pseudoinverse
def airt_pinv(g,H,n_iter):
    N = H.shape[1]
    f = cp.zeros((N,1))
    n_iter_alpha = 100
    cost = cp.zeros(n_iter)
    alpha = 0.95*2/operator_norm(H,n_iter_alpha)
    for i in range(n_iter):
        residual = H*f-g
        cost[i] = cula.norm(residual)**2
        grad = H.T*residual
        grad_norm = cula.norm(grad)
        if i==0:
            grad_norm_init = grad_norm
        grad_norm_ratio = grad_norm/grad_norm_init
        if i%100 == 0:
            print(f'i = {i}, residual_norm = {cost[i]}, grad_norm_ratio = {grad_norm_ratio}')
        f = f - alpha*grad
        if grad_norm_ratio<=1e-6:
            break
    f = f.reshape(int(np.sqrt(N)),int(np.sqrt(N)))
    return f,cost,i

# n_iter = 10000000 # Maximum number of Landweber iterations
# H_sp = sio.loadmat('H_la_120.mat')['H'] # sparse system matrix generated by AIRTools II in matlab
# H = cusp.csc_matrix(H_sp) # system matrix moved from host to device
# mu_max = 0.01 # Maximum attenuation coefficient
# f_np = np.load('./real_1/gt_1.npy') # True object in [0,1]
# f = mu_max*cp.asarray(f_np.reshape(512**2,1)) # True object in [0,mu_max] moved to device

# parser = argparse.ArgumentParser()
# parser.add_argument('-pinv',action='store_true',help='compute pseudoinverse from noisy measurements')
# parser.add_argument('-I', type=float, help='X-ray current intensity')
# args = parser.parse_args()

# g = H*f # Noiseless measurements
# if args.pinv: # Add Poisson noise if testing pseudoinverse computation
#     g = add_noise(g,args.I)

# # Compute the pseudoinverse
# start_time = time.time()
# f_pinv_cp,cost_cp,stop_i = airt_pinv(g,H,n_iter)
# elapsed = time.time() - start_time
# print(f'Elapsed time = {elapsed} secs.')

# f_pinv = cp.asnumpy(f_pinv_cp)
# cost = cp.asnumpy(cost_cp)
# if args.pinv:
#     np.save(f'./cupy_pinv_images/f_pinv_{args.I}.npy',f_pinv)
#     np.save(f'./cupy_pinv_images/cost_pinv_{args.I}.npy',cost)
#     np.save(f'./cupy_pinv_images/si_pinv_{args.I}.npy',stop_i)
# else:
#     np.save('./cupy_pinv_images/f_meas.npy',f_pinv)
#     np.save('./cupy_pinv_images/cost_meas.npy',cost)
#     np.save('./cupy_pinv_images/si_meas.npy',stop_i)







